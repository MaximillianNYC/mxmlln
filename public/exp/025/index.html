<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatty Chatty</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #F8FAFC;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding-bottom: 100px;
        }

        h1 {
            color: var(--N8, #334155);
            text-align: center;
            font-family: Spectral;
            font-size: 48px;
            font-style: normal;
            font-weight: 200;
            line-height: 110%;
            letter-spacing: -1.44px;
            margin-bottom: 32px;
        }

        .search-container {
            position: relative;
            width: 500px;
        }

        .search-input {
            position: absolute;
            bottom: 24px;
            left: 24px;
            width: calc(100% - 48px);
            padding: 15px 20px;
            border: 1px solid #e0e0e0;
            border-radius: 16px;
            background: #fff;
            color: #333;
            font-size: 16px;
            font-weight: 200;
            transition: all 0.3s ease;
            caret-color: #1DCD98;
            box-shadow: 0 481px 135px 0 rgba(0, 0, 0, 0.00), 0 308px 123px 0 rgba(0, 0, 0, 0.01), 0 173px 104px 0 rgba(0, 0, 0, 0.05), 0 77px 77px 0 rgba(0, 0, 0, 0.09), 0 19px 42px 0 rgba(0, 0, 0, 0.10);
        }

        .search-input::placeholder {
            color: #64748B;
            font-family: Inter;
            font-size: 14px;
            font-style: normal;
            line-height: 150%;
            opacity: 1;
        }

        .search-input:focus {
            outline: none;
            border-color: #E2E8F0;
        }

        .blur-wrap {
            will-change: filter;
            position: relative;
            filter: blur(0px);
            opacity: 1;
            transition: filter 0.6s ease, opacity 1s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 16px;
        }

        .blur-wrap svg {
            animation: pulseBlur 3s infinite;
        }

        @keyframes pulseBlur {
            0%, 100% { filter: blur(30px); }
            50%      { filter: blur(15px); }
        }
    </style>
</head>
<body>
    <div class="search-container">
        <div class="blur-wrap">
            <svg width="300" height="300" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
            <defs>
                <linearGradient id="shimmer" x1="-350" y1="0" x2="50" y2="0" gradientUnits="userSpaceOnUse" spreadMethod="repeat">
                    <stop offset="0%" stop-color="rgba(29, 205, 152, 0.25)"/>
                    <stop offset="15%" stop-color="rgba(29, 205, 152, 0.25)"/>
                    <stop offset="50%" stop-color="rgba(29, 205, 152, 0.75)"/>
                    <stop offset="85%" stop-color="rgba(29, 205, 152, 0.25)"/>
                    <stop offset="100%" stop-color="rgba(29, 205, 152, 0.25)"/>
                    <animate attributeName="x1" values="-350;50" dur="3s" repeatCount="indefinite" calcMode="linear" />
                    <animate attributeName="x2" values="50;450" dur="3s" repeatCount="indefinite" calcMode="linear" />
                </linearGradient>
                <radialGradient id="sphereLight" cx="-100" cy="100" gradientUnits="userSpaceOnUse">
                    <stop offset="0%" stop-color="rgba(29, 205, 152, 0.5)"/>
                    <stop offset="30%" stop-color="rgba(29, 205, 152, 0.4)"/>
                    <stop offset="50%" stop-color="rgba(29, 205, 152, 0.3)"/>
                    <stop offset="70%" stop-color="rgba(29, 205, 152, 0)"/>
                    <animate attributeName="cx" values="-100;300" dur="3s" repeatCount="indefinite" calcMode="linear" />
                </radialGradient>
            </defs>
            <circle cx="100" cy="100" r="80" fill="url(#shimmer)" />
            <circle cx="100" cy="100" r="80" fill="url(#sphereLight)" />
            </svg>
        </div>
        <div style="display: flex; width: 100%;justify-content: center; align-items: center;">
            <h1>What's on your mind?</h1>
        </div>
    </div>
    <input type="text" class="search-input" placeholder="Ask anything" autofocus id="chat-input">
    <script>
        const input = document.getElementById('chat-input');
        const h1 = document.querySelector('h1');
        console.log('h1 element found:', h1);
        let messages = [];

        // Handle form submission
        input.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' && input.value.trim()) {
                e.preventDefault();
                const userMessage = input.value.trim();
                console.log('Sending message:', userMessage);
                input.value = '';
                input.disabled = true;

                // Reset h1 text
                if (h1) {
                    h1.textContent = '';
                    console.log('Reset h1 text');
                } else {
                    console.error('h1 element not found when trying to reset!');
                }

                // Add user message to messages array
                messages.push({ role: 'user', content: userMessage });
                console.log('Messages array:', messages);

                try {
                    console.log('Fetching /api/chat...');
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ messages }),
                    });

                    console.log('Response status:', response.status, response.statusText);
                    console.log('Response headers:', [...response.headers.entries()]);

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Response not OK:', errorText);
                        throw new Error(`Network response was not ok: ${response.status} ${errorText}`);
                    }

                    if (!response.body) {
                        throw new Error('Response body is null');
                    }

                    // Handle streaming response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let assistantMessage = '';
                    let buffer = '';
                    let chunkCount = 0;

                    console.log('Starting to read stream...');
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            console.log('Stream done. Final message length:', assistantMessage.length);
                            break;
                        }

                        chunkCount++;
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            
                            // Parse AI SDK data stream format
                            // Format can be: 0:{"type":"text-delta","textDelta":"..."}
                            // or: 0:"Hello" (plain string chunks)
                            const colonIndex = line.indexOf(':');
                            if (colonIndex === -1) {
                                continue;
                            }
                            
                            const data = line.slice(colonIndex + 1);
                            try {
                                const parsed = JSON.parse(data);
                                
                                // Handle text-delta chunks (streaming) - JSON format
                                if (parsed.type === 'text-delta' && parsed.textDelta) {
                                    assistantMessage += parsed.textDelta;
                                    if (h1) {
                                        h1.textContent = assistantMessage;
                                    }
                                }
                                // Handle text chunks (complete text)
                                else if (parsed.type === 'text' && parsed.text) {
                                    assistantMessage = parsed.text;
                                    if (h1) {
                                        h1.textContent = assistantMessage;
                                    }
                                }
                                // Handle plain string chunks (direct text deltas)
                                else if (typeof parsed === 'string') {
                                    assistantMessage += parsed;
                                    if (h1) {
                                        h1.textContent = assistantMessage;
                                    }
                                }
                                // Handle error chunks
                                else if (parsed.type === 'error') {
                                    console.error('Error in stream:', parsed);
                                    if (h1) {
                                        h1.textContent = 'Error: ' + (parsed.message || parsed.error || 'Unknown error');
                                    }
                                }
                                // Skip metadata chunks (messageId, finishReason, usage, etc.)
                                else if (parsed.messageId || parsed.finishReason || parsed.usage) {
                                    // These are metadata chunks, skip them
                                }
                                // Handle other types
                                else if (parsed.type) {
                                    console.log('Unhandled chunk type:', parsed.type);
                                }
                            } catch (e) {
                                // If JSON parsing fails, it might be a plain string without quotes
                                // Try to use it as-is if it looks like text
                                if (data && typeof data === 'string' && data.length > 0) {
                                    assistantMessage += data;
                                    if (h1) {
                                        h1.textContent = assistantMessage;
                                    }
                                }
                            }
                        }
                    }

                    console.log('Finished reading stream. Total chunks:', chunkCount);
                    console.log('Final assistant message:', assistantMessage);

                    // Add assistant message to messages array
                    if (assistantMessage) {
                        messages.push({ role: 'assistant', content: assistantMessage });
                    } else {
                        console.warn('No assistant message received!');
                        h1.textContent = 'No response received';
                    }
                } catch (error) {
                    console.error('Error:', error);
                    console.error('Error stack:', error.stack);
                    h1.textContent = 'Error: ' + error.message;
                } finally {
                    input.disabled = false;
                    input.focus();
                }
            }
        });
    </script>
</body>
</html>
